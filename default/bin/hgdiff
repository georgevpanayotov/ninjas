#!/usr/bin/python3

import asyncio
import os
import subprocess
import sys
import tempfile


# Input: <REV1> [<REV2> [<PATH>]]
# Input: <REV1> [-- <PATH>]
# Input: [-- <PATH>]

class Args:
    def __init__(self, revs, path):
        self.revs = revs
        self.path = path

    def __str__(self):
        return f"{self.revs} -- {self.path}"


def getArgs(argv):
    i = 1
    revs = []
    while i < len(argv) and argv[i] != "--":
        revs.append(argv[i])

        i = i + 1

    # Skip over the "--"
    i = i + 1

    path = None
    if i < len(argv):
        path = argv[i]

    if i < len(argv) - 1:
        print(f"Unexpected paths[Max 1]: {argv[i + 1:]}")
        return None

    if len(revs) > 2:
        print(f"Unexpected revs[Max 2]: {revs[2:]}.")
        return None

    return Args(revs, path)


class DiffRecord:
    def __init__(self, action, currFile, prevFile):
        self.action = action
        self.currFile = currFile
        self.prevFile = prevFile

    def __str__(self):
        return f"{self.action} {self.currFile} {self.prevFile}"


def grabLine(lines, i):
    if i >= len(lines):
        return None
    line = lines[i]
    if len(line) == 0:
        return None

    return line

def normalizeRev(rev):
    revName = subprocess.run(f"hg id -i -r {rev}", executable = "/bin/zsh", shell = True,
                   text = True, capture_output = True, check = True)
    return revName.stdout.strip()



class DiffManager:
    def __init__(self, args, tmpdirname):
        self.args = args
        self.tmpdirname = tmpdirname
        self._normalizedArgs = None
        self.queue = asyncio.Queue()
        self.terminate = False


    def _getNormalizedArgs(self):
        if self._normalizedArgs is None:
            self._normalizedArgs = self._normalizeArgs()
        return self._normalizedArgs


    def _statusCommand(self):
        pathPart = ""
        if self.args.path is not None:
            pathPart = f" {self.args.path}"

        if len(self.args.revs) == 0:
            return f"hg st -C{pathPart}"
        elif len(self.args.revs) == 1:
            return f"hg st -C --rev {self.args.revs[0]}{pathPart}"
        else:
            return f"hg st -C --rev {self.args.revs[0]}:{self.args.revs[1]}{pathPart}"


    def _normalizeArgs(self):
        return Args([normalizeRev(rev) for rev in self.args.revs], self.args.path)



    # Does `hg cat` to save the content of a file at a particular rev. Returns the temp file where that
    # will be saved.
    async def _doHgCat(self, rev, filename):
        revDir = f"{self.tmpdirname}/{rev}"
        os.makedirs(f"{revDir}/{os.path.dirname(filename)}", exist_ok = True)

        tmpFile = f"{revDir}/{filename}"
        proc = await asyncio.create_subprocess_shell(f"hg cat -r {rev} {filename} > {tmpFile}",
                                                     executable = "/bin/zsh", shell = True)
        await proc.wait()
        return tmpFile


    async def _diffCommand(self, diffRecord):
        # The actual command should use normalized args so that we can try to mkdir with something
        # more reasonable.
        args = self._getNormalizedArgs()

        # If no revs are specified, we assume that the left rev is the currently checked out rev.
        leftRev = "."
        if len(args.revs) > 0:
            leftRev = args.revs[0]

        # If no second rev is specified, assume that the right rev is the current file state.
        rightFile = diffRecord.currFile
        if len(args.revs) > 1:
            rightFile = await self._doHgCat(args.revs[1], diffRecord.currFile)

        command = None
        if diffRecord.action == "M":
            leftFile = await self._doHgCat(leftRev, diffRecord.currFile)
            command = f"vimdiff {leftFile} {rightFile}"
        elif diffRecord.action == "A" and diffRecord.prevFile is None:
            command = f"vim {rightFile}"
        elif diffRecord.action == "A" and diffRecord.prevFile is not None:
            leftFile = await self._doHgCat(leftRev, diffRecord.prevFile)
            command = f"vimdiff {leftFile} {rightFile}"

        # Allows vim to access to tty so it can render properly.
        if command is not None:
            command = f"{command} < /dev/tty > /dev/tty"

        return command


    # Print a user readable version of the command.
    def _strCommand(self, diffRecord):
        # If no revs are specified, we assume that the left rev is the currently checked out rev.
        leftRev = "."
        if len(self.args.revs) > 0:
            leftRev = self.args.revs[0]

        # If no second rev is specified, assume that the right rev is the current file state.
        rightFile = diffRecord.currFile
        if len(self.args.revs) > 1:
            rightFile = f"{diffRecord.currFile} at {self.args.revs[1]}"

        command = None
        if diffRecord.action == "M":
            command = f"comparing {diffRecord.currFile} at {leftRev} with {rightFile}"
        elif diffRecord.action == "A" and diffRecord.prevFile is None:
            command = f"added {rightFile}"
        elif diffRecord.action == "A" and diffRecord.prevFile is not None:
            command = f"comparing {diffRecord.prevFile} at {leftRev} with {rightFile}"

        return command


    def _getRecords(self):
        statusProcess = subprocess.run(self._statusCommand(), shell = True, capture_output = True,
                                       check = True, text = True)

        lines = statusProcess.stdout.split('\n')
        records = []

        i = 0
        while i < len(lines):
            line = grabLine(lines, i)
            if line is None:
                i = i + 1
                continue

            if line[0] == "M":
                records.append(DiffRecord("M", line[2:], None))
            elif line[0] == "A":
                nextLine = grabLine(lines, i + 1)

                if nextLine is not None and nextLine[0] != " ":
                    nextLine = None

                if nextLine is None:
                    records.append(DiffRecord("A", line[2:], None))
                else:
                    i = i + 1
                    records.append(DiffRecord("A", line[2:], nextLine[2:]))

            i = i + 1

        return records


    async def createCommands(self):
        records = self._getRecords()

        for record in records:
            if self.terminate:
                return

            command = await self._diffCommand(record)
            printCommand = self._strCommand(record)
            await self.queue.put((command, printCommand))


        # Tell the consumer that we're done so it should stop trying to access the queue.
        await self.queue.put((None, None))


    async def executeCommands(self):
        while True:
            (command, printCommand) = await self.queue.get()
            if command is None or printCommand is None:
                # Detect that we're done.
                self.queue.task_done()
                return

            print(printCommand)
            proc = await asyncio.create_subprocess_shell(command, executable = "/bin/zsh", shell = True)
            exitCode = await proc.wait()

            if exitCode != 0:
                # Non-zero exit is a valid way to stop vim. Using it to signify that we're done
                # diffing and exit gracefully.
                print("Editor returned non-zero code. Ending diff.")
                self.queue.task_done()
                self.terminate = True
                return


async def main():
    args = getArgs(sys.argv)
    if args is None:
        return

    with tempfile.TemporaryDirectory() as tmpdirname:
        diffManager = DiffManager(args, tmpdirname)

        consumer = asyncio.create_task(diffManager.executeCommands())
        producer = asyncio.create_task(diffManager.createCommands())

        # First let the producer complete to make sure we generate commands for all of the records.
        await asyncio.gather(producer)
        # Now make sure the consumer has an opportunity to execute all of the commands.
        await asyncio.gather(consumer)

        consumer.cancel()

if __name__ == "__main__":
    asyncio.run(main())
